# ============================================
# AUTOMATYZACJE ALGORYTMU ZARZÄ„DZANIA BATERIÄ„
# Zgodne z harmonogramem z ALGORITHM.md
# ============================================

# ============================================
# 21:05 - Oblicz strategiÄ™ dziennÄ… (okres 22:00 - 21:59)
# ============================================

- id: battery_calculate_daily_strategy
  alias: "[Bateria] Oblicz strategiÄ™ dziennÄ… 21:05"
  description: "Oblicza Target SOC na okres 22:00 dziÅ› - 21:59 jutro (peÅ‚na doba od L2 noc)"
  trigger:
    - platform: time
      at: "21:05:00"
  action:
    # 1. Oblicz strategiÄ™ dziennÄ… (Target SOC)
    - service: python_script.calculate_daily_strategy
    # 2. Uruchom algorytm (wypeÅ‚ni analizÄ™ najtaÅ„szych godzin)
    - delay:
        seconds: 5
    - service: python_script.battery_algorithm
  mode: single

# ============================================
# CO 1 GODZINÄ˜ - Wykonaj strategiÄ™ (gÅ‚Ã³wna pÄ™tla)
# ============================================

- id: battery_execute_strategy_hourly
  alias: "[Bateria] Wykonaj strategiÄ™ (co 1h)"
  description: "GÅ‚Ã³wna pÄ™tla algorytmu - wykonywana co godzinÄ™"
  trigger:
    - platform: time_pattern
      hours: "*"
      minutes: "00"
  action:
    - service: python_script.battery_algorithm
  mode: single

# ============================================
# KLUCZOWE MOMENTY - Dodatkowe wykonanie strategii
# ============================================

- id: battery_execute_strategy_key_moments
  alias: "[Bateria] Wykonaj strategiÄ™ (kluczowe momenty)"
  description: "Dodatkowe wykonanie przy zmianach stref taryfowych"
  trigger:
    # PoczÄ…tek okna CWU rano
    - platform: time
      at: "04:30:00"
    # Zmiana L2 â†’ L1 rano
    - platform: time
      at: "06:00:00"
    # Zmiana L1 â†’ L2 poÅ‚udnie
    - platform: time
      at: "13:00:00"
    # Zmiana L2 â†’ L1 poÅ‚udnie
    - platform: time
      at: "15:00:00"
    # SZCZYT wieczorny + arbitraÅ¼
    - platform: time
      at: "19:00:00"
    # Zmiana L1 â†’ L2 wieczÃ³r + Å‚adowanie
    - platform: time
      at: "22:00:00"
  action:
    - service: python_script.battery_algorithm
  mode: single

# ============================================
# SOC PRZEKROCZYÅ PRÃ“G - URUCHOM ALGORYTM
# ============================================

- id: battery_soc_threshold_crossed
  alias: "[Bateria] SOC przekroczyÅ‚ prÃ³g - uruchom algorytm"
  description: "Uruchamia algorytm gdy SOC przekroczy ktÃ³rykolwiek z progÃ³w sezonowych (min/max/rezerwa)"
  trigger:
    # === SPADEK PONIÅ»EJ (sezonowe minimum) ===
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      below: 10  # min zima
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      below: 15  # min wiosna/jesieÅ„
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      below: 20  # min lato
    # === WZROST POWYÅ»EJ (sezonowe maximum / rezerwa) ===
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      above: 30  # rezerwa weekend (nie-zima)
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      above: 80  # max lato + rezerwa weekend zima
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      above: 85  # max wiosna/jesieÅ„
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      above: 90  # max zima
  action:
    - service: python_script.battery_algorithm
  mode: single

# ============================================
# MONITOROWANIE KRYTYCZNE (co 1 minutÄ™)
# ============================================

- id: battery_monitor_critical_soc
  alias: "[Bateria] Monitor SOC krytyczne"
  description: "Monitoruje SOC i reaguje na krytyczne wartoÅ›ci (<5%)"
  trigger:
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      below: 5
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸš¨ BATERIA KRYTYCZNIE NISKA!"
        message: "SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}% - wymuszam Å‚adowanie awaryjne!"
    - service: python_script.battery_algorithm
  mode: single

- id: battery_monitor_critical_soc_l1
  alias: "[Bateria] Monitor SOC niskie w L1"
  description: "OstrzeÅ¼enie gdy SOC niskie w drogie strefie L1"
  trigger:
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      below: 20
  condition:
    - condition: state
      entity_id: sensor.strefa_taryfowa
      state: "L1"
  action:
    - service: persistent_notification.create
      data:
        title: "âš ï¸ Bateria niska w L1"
        message: "SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}% w drogie strefie L1!"
  mode: single

- id: battery_monitor_soc_max
  alias: "[Bateria] Monitor SOC maksymalne"
  description: "Backup awaryjny - zatrzymuje Å‚adowanie gdy SOC przekroczy 90% (algorytm powinien zatrzymaÄ‡ przy 80%)"
  trigger:
    - platform: numeric_state
      entity_id: sensor.akumulatory_stan_pojemnosci
      above: 90
  action:
    - service: switch.turn_off
      target:
        entity_id: switch.akumulatory_ladowanie_z_sieci
    - service: persistent_notification.create
      data:
        title: "âœ… Bateria naÅ‚adowana"
        message: "SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}% - zatrzymano Å‚adowanie"
  mode: single

# ============================================
# WYBUDZANIE BATERII Z SLEEP MODE
# ============================================

- id: battery_wake_from_sleep_l2_night
  alias: "[Bateria] WybudÅº ze Sleep o 21:20 (przed L2 noc)"
  description: "Wymusza Å‚adowanie gdy bateria jest w Sleep mode/Standby - max 5 prÃ³b wybudzenia przed L2 22:00. Start 40 min wczeÅ›niej bo bateria moÅ¼e potrzebowaÄ‡ do 45 min na wybudzenie!"
  trigger:
    - platform: time
      at: "21:20:00"
  condition:
    - condition: or
      conditions:
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Sleep mode"
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Standby"
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Offline"
    - condition: template
      value_template: >
        {{ states('sensor.akumulatory_stan_pojemnosci') | float(0) <= states('input_number.battery_target_soc') | float(80) }}
  action:
    # Zapisz poczÄ…tkowy status
    - variables:
        initial_status: "{{ states('sensor.akumulatory_status') }}"
    # PÄ™tla max 5 prÃ³b wybudzenia
    - repeat:
        count: 5
        sequence:
          # PrÃ³ba wybudzenia
          - service: huawei_solar.forcible_charge
            data:
              device_id: "7aa193fa5ec07dc7da9f5034f97e6987"
              power: 5000
              duration: 30
          # Czekaj 60 sekund na reakcjÄ™ baterii
          - delay:
              seconds: 60
          # SprawdÅº czy bateria siÄ™ wybudziÅ‚a
          - if:
              - condition: state
                entity_id: sensor.akumulatory_status
                state: "Running"
            then:
              # Sukces! Powiadom i zakoÅ„cz
              - service: persistent_notification.create
                data:
                  title: "ğŸ”‹ Bateria wybudzona (21:20)"
                  message: |
                    âœ… Bateria wybudzona po {{ repeat.index }} prÃ³bie/prÃ³bach.
                    Status: {{ initial_status }} â†’ Running
                    SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}%
                  notification_id: battery_wake_night
              - service: python_script.battery_algorithm
              - stop: "Bateria wybudzona pomyÅ›lnie"
    # Po 5 prÃ³bach - sprawdÅº czy siÄ™ udaÅ‚o
    - if:
        - condition: template
          value_template: "{{ states('sensor.akumulatory_status') != 'Running' }}"
      then:
        # Niepowodzenie po 5 prÃ³bach
        - service: persistent_notification.create
          data:
            title: "ğŸš¨ BÅÄ„D: Nie udaÅ‚o siÄ™ wybudziÄ‡ baterii!"
            message: |
              âŒ Po 5 prÃ³bach bateria nadal nie pracuje!

              **Status:** {{ states('sensor.akumulatory_status') }}
              **SOC:** {{ states('sensor.akumulatory_stan_pojemnosci') }}%
              **Czas:** {{ now().strftime('%H:%M:%S') }}

              âš ï¸ SprawdÅº bateriÄ™ rÄ™cznie!
              MoÅ¼liwe przyczyny:
              - Awaria komunikacji Modbus
              - Bateria w trybie Fault
              - Problem z inwerterem
            notification_id: battery_wake_night_failed
  mode: single

- id: battery_wake_from_sleep_l2_midday
  alias: "[Bateria] WybudÅº ze Sleep o 12:40 (przed L2 poÅ‚udnie)"
  description: "Wymusza Å‚adowanie gdy bateria jest w Sleep mode/Standby - max 5 prÃ³b wybudzenia przed L2 13:00"
  trigger:
    - platform: time
      at: "12:40:00"
  condition:
    - condition: state
      entity_id: binary_sensor.dzien_roboczy
      state: "on"
    - condition: or
      conditions:
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Sleep mode"
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Standby"
        - condition: state
          entity_id: sensor.akumulatory_status
          state: "Offline"
    - condition: template
      value_template: >
        {{ states('sensor.akumulatory_stan_pojemnosci') | float(0) <= states('input_number.battery_target_soc') | float(80) }}
  action:
    # Zapisz poczÄ…tkowy status
    - variables:
        initial_status: "{{ states('sensor.akumulatory_status') }}"
    # PÄ™tla max 5 prÃ³b wybudzenia
    - repeat:
        count: 5
        sequence:
          # PrÃ³ba wybudzenia
          - service: huawei_solar.forcible_charge
            data:
              device_id: "7aa193fa5ec07dc7da9f5034f97e6987"
              power: 5000
              duration: 30
          # Czekaj 60 sekund na reakcjÄ™ baterii
          - delay:
              seconds: 60
          # SprawdÅº czy bateria siÄ™ wybudziÅ‚a
          - if:
              - condition: state
                entity_id: sensor.akumulatory_status
                state: "Running"
            then:
              # Sukces! Powiadom i zakoÅ„cz
              - service: persistent_notification.create
                data:
                  title: "ğŸ”‹ Bateria wybudzona (12:40)"
                  message: |
                    âœ… Bateria wybudzona po {{ repeat.index }} prÃ³bie/prÃ³bach.
                    Status: {{ initial_status }} â†’ Running
                    SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}%
                  notification_id: battery_wake_midday
              - service: python_script.battery_algorithm
              - stop: "Bateria wybudzona pomyÅ›lnie"
    # Po 5 prÃ³bach - sprawdÅº czy siÄ™ udaÅ‚o
    - if:
        - condition: template
          value_template: "{{ states('sensor.akumulatory_status') != 'Running' }}"
      then:
        # Niepowodzenie po 5 prÃ³bach
        - service: persistent_notification.create
          data:
            title: "ğŸš¨ BÅÄ„D: Nie udaÅ‚o siÄ™ wybudziÄ‡ baterii!"
            message: |
              âŒ Po 5 prÃ³bach bateria nadal nie pracuje!

              **Status:** {{ states('sensor.akumulatory_status') }}
              **SOC:** {{ states('sensor.akumulatory_stan_pojemnosci') }}%
              **Czas:** {{ now().strftime('%H:%M:%S') }}

              âš ï¸ SprawdÅº bateriÄ™ rÄ™cznie!
              MoÅ¼liwe przyczyny:
              - Awaria komunikacji Modbus
              - Bateria w trybie Fault
              - Problem z inwerterem
            notification_id: battery_wake_midday_failed
  mode: single

# ============================================
# DIAGNOSTYKA WYBUDZANIA (INFORMACJE O POMINIÄ˜CIU)
# ============================================

- id: battery_wake_diagnostic_l2_night
  alias: "[Bateria] ğŸ” Diagnostyka - status po prÃ³bie wybudzenia o 21:20"
  description: "Informuje o statusie baterii o 21:21 (gdy wybudzanie pominiÄ™te)"
  trigger:
    - platform: time
      at: "21:21:00"
  condition:
    # Uruchom tylko jeÅ›li bateria NIE pracuje (czyli wybudzanie nie zadziaÅ‚aÅ‚o)
    - condition: template
      value_template: >
        {% set status = states('sensor.akumulatory_status') %}
        {% set soc = states('sensor.akumulatory_stan_pojemnosci') | float(0) %}
        {% set target = states('input_number.battery_target_soc') | float(80) %}
        {{ (status not in ['Sleep mode', 'Standby']) or (soc > target) }}
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸ” Status baterii o 21:21 - diagnostyka"
        message: |
          **Status baterii:** {{ states('sensor.akumulatory_status') }}
          **SOC:** {{ states('sensor.akumulatory_stan_pojemnosci') }}%
          **Target SOC:** {{ states('input_number.battery_target_soc') }}%

          **Analiza (wybudzanie o 21:20 zostaÅ‚o pominiÄ™te):**
          {% set status = states('sensor.akumulatory_status') %}
          {% set soc = states('sensor.akumulatory_stan_pojemnosci') | float(0) %}
          {% set target = states('input_number.battery_target_soc') | float(80) %}

          {% if status == 'Running' %}
          âœ… Bateria juÅ¼ pracuje (Running) - wybudzanie niepotrzebne
          {% elif status == 'Offline' %}
          âš ï¸ Bateria OFFLINE - sprawdÅº poÅ‚Ä…czenie!
          {% elif status == 'Fault' %}
          ğŸ”´ Bateria w stanie FAULT - sprawdÅº bÅ‚Ä™dy!
          {% elif soc > target %}
          âœ… SOC ({{ soc }}%) > Target ({{ target }}%) - Å‚adowanie niepotrzebne
          {% else %}
          â“ Status: {{ status }} - nieznana przyczyna
          {% endif %}

          Algorytm uruchomi siÄ™ o 22:00:00 (gÅ‚Ã³wna pÄ™tla).
        notification_id: battery_wake_diagnostic_night
  mode: single

- id: battery_wake_diagnostic_l2_midday
  alias: "[Bateria] ğŸ” Diagnostyka - status po prÃ³bie wybudzenia o 12:40"
  description: "Informuje o statusie baterii o 12:41 (gdy wybudzanie pominiÄ™te)"
  trigger:
    - platform: time
      at: "12:41:00"
  condition:
    # Uruchom tylko w dni robocze i jeÅ›li bateria NIE zostaÅ‚a wybudzona
    - condition: state
      entity_id: binary_sensor.dzien_roboczy
      state: "on"
    - condition: template
      value_template: >
        {% set status = states('sensor.akumulatory_status') %}
        {% set soc = states('sensor.akumulatory_stan_pojemnosci') | float(0) %}
        {% set target = states('input_number.battery_target_soc') | float(80) %}
        {{ (status not in ['Sleep mode', 'Standby']) or (soc > target) }}
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸ” Status baterii o 12:41 - diagnostyka"
        message: |
          **Status baterii:** {{ states('sensor.akumulatory_status') }}
          **SOC:** {{ states('sensor.akumulatory_stan_pojemnosci') }}%
          **Target SOC:** {{ states('input_number.battery_target_soc') }}%

          **Analiza (wybudzanie o 12:40 zostaÅ‚o pominiÄ™te):**
          {% set status = states('sensor.akumulatory_status') %}
          {% set soc = states('sensor.akumulatory_stan_pojemnosci') | float(0) %}
          {% set target = states('input_number.battery_target_soc') | float(80) %}

          {% if status == 'Running' %}
          âœ… Bateria juÅ¼ pracuje (Running) - wybudzanie niepotrzebne
          {% elif status == 'Offline' %}
          âš ï¸ Bateria OFFLINE - sprawdÅº poÅ‚Ä…czenie!
          {% elif status == 'Fault' %}
          ğŸ”´ Bateria w stanie FAULT - sprawdÅº bÅ‚Ä™dy!
          {% elif soc > target %}
          âœ… SOC ({{ soc }}%) > Target ({{ target }}%) - Å‚adowanie niepotrzebne
          {% else %}
          â“ Status: {{ status }} - nieznana przyczyna
          {% endif %}

          Algorytm uruchomi siÄ™ o 13:00:00 (gÅ‚Ã³wna pÄ™tla kluczowych momentÃ³w).
        notification_id: battery_wake_diagnostic_midday
  mode: single

# ============================================
# POBIERANIE PROGNOZ
# ============================================

- id: battery_update_forecast_morning
  alias: "[Bateria] Aktualizuj prognozÄ™ PV (04:00)"
  description: "Pobiera prognozÄ™ PV rano przed obliczeniem strategii"
  trigger:
    - platform: time
      at: "03:55:00"
  action:
    - service: homeassistant.update_entity
      target:
        entity_id:
          - sensor.energy_production_today
          - sensor.energy_production_tomorrow
  mode: single

- id: battery_update_forecast_noon
  alias: "[Bateria] Aktualizuj prognozÄ™ PV (12:00)"
  description: "Pobiera prognozÄ™ PV w poÅ‚udnie"
  trigger:
    - platform: time
      at: "12:00:00"
  action:
    - service: homeassistant.update_entity
      target:
        entity_id:
          - sensor.energy_production_today
          - sensor.energy_production_tomorrow
  mode: single

- id: battery_update_forecast_evening
  alias: "[Bateria] Aktualizuj prognozÄ™ PV (20:00)"
  description: "Pobiera prognozÄ™ PV wieczorem"
  trigger:
    - platform: time
      at: "20:00:00"
  action:
    - service: homeassistant.update_entity
      target:
        entity_id:
          - sensor.energy_production_today
          - sensor.energy_production_tomorrow
  mode: single

# ============================================
# POBIERANIE CEN RCE
# ============================================

- id: battery_fetch_rce_prices
  alias: "[Bateria] OdÅ›wieÅ¼ ceny RCE (18:00)"
  description: "OdÅ›wieÅ¼a ceny RCE PSE o 18:00 (po publikacji cen na jutro)"
  trigger:
    - platform: time
      at: "18:00:00"
  action:
    # Losowe opÃ³Åºnienie 0-15 min (Å¼eby nie obciÄ…Å¼aÄ‡ API)
    - delay:
        seconds: "{{ range(0, 900) | random }}"
    - service: homeassistant.update_entity
      target:
        entity_id:
          - sensor.rce_pse_cena
  mode: single

# ============================================
# BEZPIECZEÅƒSTWO TERMICZNE BATERII
# ============================================

- id: battery_temperature_warning
  alias: "[Bateria] ğŸŸ  Temperatura wysoka (>40Â°C)"
  description: "OstrzeÅ¼enie o podwyÅ¼szonej temperaturze baterii (przyspieszona degradacja)"
  trigger:
    - platform: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      above: 40
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸŸ  OSTRZEÅ»ENIE: Temperatura baterii wysoka!"
        message: |
          âš ï¸ Temperatura baterii: {{ states('sensor.bateria_temperatura_maksymalna') }}Â°C

          **DziaÅ‚ania:**
          - Zredukowano intensywnoÅ›Ä‡ Å‚adowania
          - Monitoruj temperaturÄ™ przez kolejne 30 min

          **Przyczyny:**
          - Intensywne Å‚adowanie/rozÅ‚adowanie
          - Wysoka temperatura otoczenia
          - SÅ‚aba wentylacja pomieszczenia

          **Bezpieczny zakres:** 15-40Â°C
        notification_id: battery_temp_warning
  mode: single

- id: battery_temperature_critical_stop_charging
  alias: "[Bateria] ğŸ”´ KRYTYCZNE: Temperatura >43Â°C - STOP Å‚adowania!"
  description: "Zatrzymuje Å‚adowanie baterii przy temperaturze >43Â°C (ochrona przed uszkodzeniem)"
  trigger:
    - platform: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      above: 43
  action:
    # NATYCHMIAST wyÅ‚Ä…cz Å‚adowanie z sieci
    - service: switch.turn_off
      target:
        entity_id: switch.akumulatory_ladowanie_z_sieci
    # Ustaw tryb bezpieczny (tylko autoconsumption, bez intensywnego Å‚adowania)
    - service: select.select_option
      target:
        entity_id: select.akumulatory_tryb_pracy
      data:
        option: "maximise_self_consumption"
    # ALARM!
    - service: persistent_notification.create
      data:
        title: "ğŸ”´ğŸš¨ ALARM: Temperatura baterii KRYTYCZNA!"
        message: |
          ğŸ”¥ TEMPERATURA BATERII: {{ states('sensor.akumulator_1_temperatura') }}Â°C

          âš ï¸ PRZEKROCZONO BEZPIECZNY PRÃ“G (43Â°C)!

          **WYKONANO AUTOMATYCZNIE:**
          âœ… Zatrzymano Å‚adowanie z sieci
          âœ… Ustawiono tryb bezpieczny (Maximise Self Consumption)

          **CO ZROBIÄ†:**
          1. SprawdÅº temperaturÄ™ pomieszczenia z bateriÄ…
          2. Zapewnij lepszÄ… wentylacjÄ™
          3. NIE WZNAWIAJ Å‚adowania dopÃ³ki temp < 35Â°C
          4. RozwaÅ¼ kontakt z serwisem Huawei

          **LIMIT BEZPIECZEÅƒSTWA:** >45Â°C = ryzyko poÅ¼aru!
        notification_id: battery_temp_critical
  mode: single

- id: battery_temperature_extreme_alarm
  alias: "[Bateria] âš« EKSTREMALNIE NIEBEZPIECZNE: Temperatura >45Â°C!"
  description: "Alarm ekstremalny - potencjalne zagroÅ¼enie poÅ¼arem"
  trigger:
    - platform: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      above: 45
  action:
    # Wszystkie moÅ¼liwe wyÅ‚Ä…czenia
    - service: switch.turn_off
      target:
        entity_id: switch.akumulatory_ladowanie_z_sieci
    - service: select.select_option
      target:
        entity_id: select.akumulatory_tryb_pracy
      data:
        option: "maximise_self_consumption"
    # EKSTREMALNY ALARM
    - service: persistent_notification.create
      data:
        title: "âš«ğŸš¨ğŸ”¥ EKSTREMALNIE NIEBEZPIECZNE: BATERIA PRZEGRZANA!"
        message: |
          ğŸ”¥ğŸ”¥ğŸ”¥ TEMPERATURA: {{ states('sensor.akumulator_1_temperatura') }}Â°C ğŸ”¥ğŸ”¥ğŸ”¥

          âš« PRZEKROCZONO EKSTREMALNY PRÃ“G (45Â°C)!
          âš ï¸ RYZYKO POÅ»ARU/USZKODZENIA BATERII!

          **NATYCHMIASTOWE DZIAÅANIA:**
          1. âŒ ODÅÄ„CZ bateriÄ™ od systemu (wyÅ‚Ä…cznik awaryjny)
          2. ğŸš’ Przygotuj gaÅ›nicÄ™ (NIE WODNÄ„ - tylko CO2/proszek ABC)
          3. ğŸƒ Ewakuuj pomieszczenie
          4. ğŸ“ ZadzwoÅ„ do serwisu Huawei NATYCHMIAST
          5. ğŸ“ W razie oznak dymu/ognia: 998 (straÅ¼ poÅ¼arna)

          **NIE IGNORUJ TEGO ALARMU!**
        notification_id: battery_temp_extreme

- id: battery_temperature_freezing
  alias: "[Bateria] â„ï¸ Temperatura poniÅ¼ej 0Â°C - mrÃ³z!"
  description: "OstrzeÅ¼enie o niskiej temperaturze (moÅ¼liwe uszkodzenie ogniw)"
  trigger:
    - platform: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      below: 0
  action:
    # WyÅ‚Ä…cz Å‚adowanie przy mrozie
    - service: switch.turn_off
      target:
        entity_id: switch.akumulatory_ladowanie_z_sieci
    - service: persistent_notification.create
      data:
        title: "â„ï¸ OSTRZEÅ»ENIE: Bateria zamarza!"
        message: |
          ğŸ¥¶ Temperatura baterii: {{ states('sensor.akumulator_1_temperatura') }}Â°C

          âš ï¸ TEMPERATURA PONIÅ»EJ 0Â°C!

          **Ryzyko:**
          - Uszkodzenie ogniw litowych
          - TrwaÅ‚a utrata pojemnoÅ›ci
          - SkrÃ³cenie Å¼ywotnoÅ›ci baterii

          **DziaÅ‚ania:**
          âœ… Zatrzymano Å‚adowanie z sieci

          **Co zrobiÄ‡:**
          1. Ogrzej pomieszczenie z bateriÄ… do min. 10Â°C
          2. Poczekaj aÅ¼ bateria siÄ™ ogrzeje
          3. NIE Å‚aduj przy temp < 5Â°C

          **Bezpieczny zakres:** 0-40Â°C (optymalnie 15-25Â°C)
        notification_id: battery_temp_freezing
  mode: single

- id: battery_temperature_normal_resumed
  alias: "[Bateria] âœ… Temperatura baterii wrÃ³ciÅ‚a do normy"
  description: "Informacja o powrocie do bezpiecznej temperatury"
  trigger:
    - platform: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      below: 38
      for:
        minutes: 15
  condition:
    # Tylko jeÅ›li wczeÅ›niej byÅ‚a wysoka
    - condition: numeric_state
      entity_id: sensor.bateria_temperatura_maksymalna
      below: 38
  action:
    - service: persistent_notification.create
      data:
        title: "âœ… Temperatura baterii bezpieczna"
        message: |
          ğŸŸ¢ Temperatura baterii: {{ states('sensor.akumulator_1_temperatura') }}Â°C

          Temperatura wrÃ³ciÅ‚a do bezpiecznego zakresu.
          Algorytm zarzÄ…dzania bateriÄ… moÅ¼e dziaÅ‚aÄ‡ normalnie.

          **Bezpieczny zakres:** 15-40Â°C
        notification_id: battery_temp_normal
    # UsuÅ„ stare alerty
    - service: persistent_notification.dismiss
      data:
        notification_id: battery_temp_warning
    - service: persistent_notification.dismiss
      data:
        notification_id: battery_temp_critical
  mode: single

# ============================================
# WATCHDOG - MONITOROWANIE PRACY ALGORYTMU
# ============================================

- id: battery_watchdog_algorithm_health
  alias: "[Bateria] Watchdog - sprawdzenie zdrowia algorytmu"
  description: "Monitoruje czy algorytm baterii dziaÅ‚a prawidÅ‚owo (sprawdza aktualizacjÄ™ decision_reason)"
  trigger:
    - platform: time_pattern
      hours: "*"
      minutes: "30"
  condition:
    # SprawdÅº czy decision_reason nie zostaÅ‚ zaktualizowany przez 2h
    - condition: template
      value_template: >
        {% set last_changed = states.input_text.battery_decision_reason.last_changed %}
        {% set now = now() %}
        {{ (now - last_changed).total_seconds() > 7200 }}
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸš¨ WATCHDOG: Algorytm baterii nie dziaÅ‚a!"
        message: |
          âš ï¸ Algorytm baterii nie aktualizowaÅ‚ decyzji przez >2h!

          Ostatnia aktualizacja: {{ states.input_text.battery_decision_reason.last_changed }}
          Obecny SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}%
          Strefa: {{ states('sensor.strefa_taryfowa') }}

          ğŸ”§ SprawdÅº logi Home Assistant i poprawnoÅ›Ä‡ konfiguracji!
        notification_id: battery_watchdog_alert
    # Ustaw tryb awaryjny - Maximise Self Consumption (bezpieczny fallback)
    - service: select.select_option
      target:
        entity_id: select.akumulatory_tryb_pracy
      data:
        option: "maximise_self_consumption"
    - service: switch.turn_off
      target:
        entity_id: switch.akumulatory_ladowanie_z_sieci
  mode: single

- id: battery_watchdog_soc_stuck
  alias: "[Bateria] Watchdog - SOC nie zmienia siÄ™"
  description: "OstrzeÅ¼enie gdy SOC nie zmienia siÄ™ przez 6h (moÅ¼liwa awaria baterii/inwertera)"
  trigger:
    - platform: state
      entity_id: sensor.akumulatory_stan_pojemnosci
      for:
        hours: 6
  action:
    - service: persistent_notification.create
      data:
        title: "âš ï¸ WATCHDOG: SOC baterii nie zmienia siÄ™!"
        message: |
          Bateria utrzymuje staÅ‚y SOC {{ states('sensor.akumulatory_stan_pojemnosci') }}% przez >6h

          MoÅ¼liwe przyczyny:
          - Awaria komunikacji z bateriÄ…
          - Zablokowany tryb pracy
          - Problem z inwerterem

          SprawdÅº fizyczne poÅ‚Ä…czenie i stan urzÄ…dzeÅ„!
        notification_id: battery_soc_stuck_alert
  mode: single

# ============================================
# ANALIZA NAJTAÅƒSZYCH GODZIN - PRZY STARCIE HA
# ============================================

- id: battery_analyze_cheapest_hours_on_startup
  alias: "[Bateria] Analiza najtaÅ„szych godzin przy starcie"
  description: "Uruchamia analizÄ™ RCE przy restarcie Home Assistant - wypeÅ‚nia input_text"
  trigger:
    - platform: homeassistant
      event: start
  action:
    - service: python_script.battery_algorithm
  mode: single

# ============================================
# POWIADOMIENIA DZIENNE
# ============================================

- id: battery_daily_summary
  alias: "[Bateria] Podsumowanie doby (00:01)"
  description: "WysyÅ‚a podsumowanie doby energetycznej (22:00-21:59) o 00:01"
  trigger:
    - platform: time
      at: "00:01:00"
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸ“Š Podsumowanie doby energetycznej (22:00-21:59)"
        message: |
          **Bateria:**
          - Obecny SOC: {{ states('sensor.akumulatory_stan_pojemnosci') }}%
          - Target SOC na dziÅ›: {{ states('input_number.battery_target_soc') }}%

          **Produkcja PV (wczoraj):**
          - Wczoraj: {{ states('sensor.inwerter_dzienna_produkcja') }} kWh
          - Prognoza dziÅ›: {{ states('sensor.prognoza_pv_dzisiaj') }} kWh

          **Ceny RCE:**
          - Aktualna cena: {{ (states('sensor.rce_pse_cena') | float / 1000) | round(3) }} zÅ‚/kWh
          - NajtaÅ„sze godziny dziÅ›: {{ states('input_text.battery_cheapest_hours') }}

          **Pogoda dziÅ›:**
          - Temp: {{ state_attr('weather.forecast_dom', 'temperature') }}Â°C
          - Sezon grzewczy: {{ states('binary_sensor.sezon_grzewczy') }}
  mode: single

# ============================================
# ZBIERANIE DANYCH O ZUZYCIU NOCNYM
# ============================================

# O 06:00 - koniec nocy, zapisz zuzycie i zaktualizuj EMA
- id: night_consumption_capture
  alias: "[Dane] Zapisz zuzycie nocne o 06:00"
  description: "Zbiera dane o zuzyciu nocnym do planowania ladowania"
  trigger:
    - platform: time
      at: "06:00:00"
  action:
    # 1. Zapisz ostatnie zuzycie nocne z utility_meter
    - service: input_number.set_value
      target:
        entity_id: input_number.night_consumption_last
      data:
        value: "{{ states('sensor.zuzycie_nocne_od_22_00') | float(0) | round(1) }}"
    # 2. Zaktualizuj EMA (waga 0.3 dla nowej wartosci)
    # EMA = alpha * new + (1-alpha) * old
    - service: input_number.set_value
      target:
        entity_id: input_number.night_consumption_avg
      data:
        value: >
          {% set alpha = 0.3 %}
          {% set new_val = states('sensor.zuzycie_nocne_od_22_00') | float(0) %}
          {% set old_avg = states('input_number.night_consumption_avg') | float(16) %}
          {{ (alpha * new_val + (1 - alpha) * old_avg) | round(1) }}
  mode: single

# O 21:00 - oblicz PV start hour na jutro
- id: pv_start_hour_calculate
  alias: "[Dane] Oblicz PV start hour o 21:00"
  description: "Znajduje pierwsza godzine z produkcja PV >500W"
  trigger:
    - platform: time
      at: "21:00:00"
  action:
    # Oblicz PV start hour z prognozy godzinowej
    # Atrybut 'watts' zawiera dict {datetime: watts}
    - service: input_number.set_value
      target:
        entity_id: input_number.pv_start_hour
      data:
        value: >
          {% set tomorrow = (now().date() + timedelta(days=1)) | string %}
          {% set watts_e = state_attr('sensor.pv_wschod_prognoza_dzis', 'watts') or {} %}
          {% set watts_s = state_attr('sensor.pv_poludnie_prognoza_dzis', 'watts') or {} %}
          {% set watts_w = state_attr('sensor.pv_zachod_prognoza_dzis', 'watts') or {} %}
          {% set ns = namespace(start_hour=8) %}
          {% for hour in range(5, 12) %}
            {% set ts = tomorrow ~ ' ' ~ '%02d' % hour ~ ':00:00' %}
            {% set total = (watts_e.get(ts, 0) | float) + (watts_s.get(ts, 0) | float) + (watts_w.get(ts, 0) | float) %}
            {% if total > 500 and ns.start_hour == 8 %}
              {% set ns.start_hour = hour %}
            {% endif %}
          {% endfor %}
          {{ ns.start_hour }}
  mode: single

# ============================================
# ZBIERANIE DANYCH GODZINOWYCH DLA ML
# ============================================

# Inicjalizacja pliku CSV przy starcie HA
- id: ml_data_init_csv
  alias: "[ML] Inicjalizuj plik CSV przy starcie"
  trigger:
    - platform: homeassistant
      event: start
  action:
    - service: shell_command.init_hourly_csv
  mode: single

# Zbieranie danych godzinowych - 1 min przed peÅ‚nÄ… godzinÄ… (przed resetem utility_meter)
- id: ml_data_hourly_collection
  alias: "[ML] Zbierz dane godzinowe"
  description: "Zapisuje dane energetyczne co godzinÄ™ do CSV dla Machine Learning"
  trigger:
    - platform: time_pattern
      hours: "*"
      minutes: "59"
  action:
    - service: shell_command.save_hourly_data
      data:
        timestamp: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
        # POPRAWIONE: Oblicz RZECZYWISTE zuÅ¼ycie domu (nie grid_import!)
        # FormuÅ‚a: real_consumption = grid_import - battery_charge + battery_discharge
        # Gdzie grid_import to sensor.zuzycie_godzinowe (utility_meter na sensor.pomiar_mocy_zuzycie)
        consumption: >
          {% set grid_import = states('sensor.zuzycie_godzinowe') | float(0) %}
          {% set battery_charge = states('sensor.ladowanie_baterii_godzinowe') | float(0) %}
          {% set battery_discharge = states('sensor.rozladowanie_baterii_godzinowe') | float(0) %}
          {{ [grid_import - battery_charge + battery_discharge, 0] | max | round(3) }}
        pv_production: "{{ states('sensor.produkcja_pv_godzinowa') | float(0) | round(3) }}"
        grid_export: "{{ states('sensor.eksport_godzinowy') | float(0) | round(3) }}"
        battery_charge: "{{ states('sensor.ladowanie_baterii_godzinowe') | float(0) | round(3) }}"
        battery_discharge: "{{ states('sensor.rozladowanie_baterii_godzinowe') | float(0) | round(3) }}"
        soc: "{{ states('sensor.akumulatory_stan_pojemnosci') | float(0) | round(1) }}"
        tariff: "{{ states('sensor.strefa_taryfowa') }}"
        temperature: "{{ states('sensor.bateria_temperatura_maksymalna') | float(0) | round(1) }}"
        rce_price: "{{ states('sensor.rce_pse_cena') | float(0) | round(2) }}"
  mode: single

# ============================================
# ZDALNY GIT PULL
# ============================================

- id: remote_git_pull
  alias: "[System] Zdalny Git Pull"
  description: "Pozwala Claude wykonaÄ‡ git pull zdalnie przez API"
  trigger:
    - platform: event
      event_type: claude_git_pull
  action:
    - service: shell_command.git_pull
    - delay:
        seconds: 2
    - service: persistent_notification.create
      data:
        title: "ğŸ”„ Git Pull"
        message: "Wykonano git pull o {{ now().strftime('%H:%M:%S') }}"
  mode: single

# ============================================
# CWU Z NADWYÅ»KI PV (TYLKO W ZIELONEJ STREFIE CENOWEJ)
# ============================================

- id: cwu_pv_surplus_enable
  alias: "[CWU] WÅ‚Ä…cz grzanie z nadwyÅ¼ki PV (zielona cena)"
  description: "WÅ‚Ä…cza wymuszenie CWU gdy: nadwyÅ¼ka PV > 2000W, cena < p33 (dynamiczny), temp < 55Â°C"
  trigger:
    # Trigger gdy nadwyÅ¼ka PV przekroczy 2000 W
    - platform: numeric_state
      entity_id: sensor.nadwyzka_pv
      above: 2000
  condition:
    # Wszystkie warunki muszÄ… byÄ‡ speÅ‚nione
    - condition: and
      conditions:
        # 1. CWU aktualnie nie grzeje (nie wymuszamy podczas normalnego cyklu)
        - condition: state
          entity_id: water_heater.bodynek_nb_tank
          state: "off"
        # 2. Wymuszenie CWU jest wyÅ‚Ä…czone (nie dublujemy)
        - condition: state
          entity_id: switch.bodynek_nb_wymus_c_w_u
          state: "off"
        # 3. Cena energii < p33 (DYNAMICZNY prÃ³g zielonej strefy)
        - condition: template
          value_template: >
            {% set cena = states('sensor.cena_zakupu_energii') | float(1) %}
            {% set p33 = state_attr('sensor.rce_progi_cenowe', 'p33') | float(0.5) %}
            {{ cena < p33 }}
        # 4. Temperatura wody < 55Â°C (zapas przed wyÅ‚Ä…czeniem)
        - condition: template
          value_template: >
            {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(60) < 55 }}
  action:
    # Oznacz Å¼e wÅ‚Ä…czono przez automatyzacjÄ™ PV
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.cwu_pv_surplus_active
    # WÅ‚Ä…cz wymuszenie CWU
    - service: switch.turn_on
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    # Powiadomienie
    - service: persistent_notification.create
      data:
        title: "ğŸŒ CWU: WÅ‚Ä…czono grzanie z nadwyÅ¼ki PV"
        message: |
          âœ… Wymuszenie CWU wÅ‚Ä…czone

          **Warunki speÅ‚nione:**
          - NadwyÅ¼ka PV: {{ states('sensor.nadwyzka_pv') }} W (> 2000 W)
          - Cena RCE: {{ states('sensor.cena_zakupu_energii') }} PLN/kWh
          - PrÃ³g p33: {{ state_attr('sensor.rce_progi_cenowe', 'p33') }} PLN/kWh
          - Temp wody: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C

          Grzanie wyÅ‚Ä…czy siÄ™ gdy:
          - NadwyÅ¼ka < 500 W LUB
          - Temp wody > 55Â°C
        notification_id: cwu_pv_surplus
  mode: single

- id: cwu_pv_surplus_disable
  alias: "[CWU] WyÅ‚Ä…cz grzanie (brak nadwyÅ¼ki lub temp osiÄ…gniÄ™ta)"
  description: "WyÅ‚Ä…cza wymuszenie CWU gdy: nadwyÅ¼ka PV < 500W LUB temp wody > 55Â°C (tylko gdy wÅ‚Ä…czone przez automatyzacjÄ™ PV)"
  trigger:
    # Trigger 1: NadwyÅ¼ka PV spadÅ‚a poniÅ¼ej 500 W
    - platform: numeric_state
      entity_id: sensor.nadwyzka_pv
      below: 500
      id: low_surplus
    # Trigger 2: Temperatura wody przekroczyÅ‚a 55Â°C
    - platform: template
      value_template: >
        {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) > 55 }}
      id: high_temp
  condition:
    # Tylko jeÅ›li CWU wÅ‚Ä…czone przez automatyzacjÄ™ PV (nie rÄ™cznie!)
    - condition: state
      entity_id: input_boolean.cwu_pv_surplus_active
      state: "on"
  action:
    # WyÅ‚Ä…cz wymuszenie CWU
    - service: switch.turn_off
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    # WyÅ‚Ä…cz flagÄ™ automatyzacji
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.cwu_pv_surplus_active
    # Powiadomienie z powodem
    - service: persistent_notification.create
      data:
        title: "ğŸŒ™ CWU: WyÅ‚Ä…czono grzanie z nadwyÅ¼ki PV"
        message: |
          âŒ Wymuszenie CWU wyÅ‚Ä…czone

          **PowÃ³d:** {% if trigger.id == 'low_surplus' %}NadwyÅ¼ka PV < 500 W{% else %}Temp wody > 55Â°C{% endif %}

          **Aktualny stan:**
          - NadwyÅ¼ka PV: {{ states('sensor.nadwyzka_pv') }} W
          - Temp wody: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
        notification_id: cwu_pv_surplus
  mode: single

# ============================================
# RÄ˜CZNE WYMUSZENIE CWU - DO OSIÄ„GNIÄ˜CIA TEMP CELU (MAX 2H)
# ============================================

- id: cwu_manual_force_auto_off
  alias: "[CWU] Wymuszenie CWU do osiÄ…gniÄ™cia temp celu (max 2h)"
  description: "Wymuszenie CWU dziaÅ‚a do osiÄ…gniÄ™cia temperatury celu, max 2h jako zabezpieczenie"
  trigger:
    - platform: state
      entity_id: switch.bodynek_nb_wymus_c_w_u
      to: "on"
  condition:
    # Tylko jeÅ›li NIE wÅ‚Ä…czone przez automatyzacjÄ™ PV (ta ma wÅ‚asne zarzÄ…dzanie)
    - condition: state
      entity_id: input_boolean.cwu_pv_surplus_active
      state: "off"
  action:
    # Powiadomienie o starcie
    - service: persistent_notification.create
      data:
        title: "ğŸŒ¡ï¸ CWU: Wymuszenie wÅ‚Ä…czone"
        message: |
          ğŸ”„ Grzanie CWU do osiÄ…gniÄ™cia temperatury celu (max 2h)

          Temp aktualna: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
          Temp docelowa: {{ state_attr('water_heater.bodynek_nb_tank', 'temperature') }}Â°C
        notification_id: cwu_manual_auto_off
    # Czekaj aÅ¼ temperatura osiÄ…gnie cel (max 2h)
    - wait_template: >
        {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) >=
           state_attr('water_heater.bodynek_nb_tank', 'temperature') | float(55) }}
      timeout:
        hours: 2
      continue_on_timeout: true
    # WyÅ‚Ä…cz wymuszenie CWU
    - service: switch.turn_off
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    # Powiadomienie o zakoÅ„czeniu
    - service: persistent_notification.create
      data:
        title: "{% if wait.completed %}âœ… CWU: Temp osiÄ…gniÄ™ta{% else %}â±ï¸ CWU: Timeout 2h{% endif %}"
        message: |
          {% if wait.completed %}
          âœ… Wymuszenie CWU wyÅ‚Ä…czone - temperatura celu osiÄ…gniÄ™ta!
          {% else %}
          â±ï¸ Wymuszenie CWU wyÅ‚Ä…czone - timeout 2h (zabezpieczenie)
          {% endif %}

          Temp koÅ„cowa: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
          Temp docelowa: {{ state_attr('water_heater.bodynek_nb_tank', 'temperature') }}Â°C
        notification_id: cwu_manual_auto_off
  mode: single

# ============================================
# WATCHDOG AQUAREA - SPRAWDZANIE TOKENU
# ============================================

- id: aquarea_watchdog_token
  alias: "[Aquarea] Watchdog - sprawdzanie poÅ‚Ä…czenia"
  description: "Co godzinÄ™ o :47 sprawdza czy integracja Aquarea dziaÅ‚a. JeÅ›li unavailable - przeÅ‚adowuje."
  trigger:
    - platform: time_pattern
      minutes: "47"
  condition:
    # SprawdÅº czy encja jest unavailable
    - condition: state
      entity_id: water_heater.bodynek_nb_tank
      state: "unavailable"
  action:
    # Powiadomienie o wykryciu problemu
    - service: persistent_notification.create
      data:
        title: "ğŸ”§ Aquarea: Wykryto problem z poÅ‚Ä…czeniem"
        message: |
          âš ï¸ Encja water_heater.bodynek_nb_tank jest niedostÄ™pna.

          ğŸ”„ PrzeÅ‚adowujÄ™ integracjÄ™ Aquarea...

          Czas: {{ now().strftime('%H:%M:%S') }}
        notification_id: aquarea_watchdog
    # PrzeÅ‚aduj integracjÄ™ Aquarea
    - service: homeassistant.reload_config_entry
      data:
        entry_id: "01KCFK1ETFE13JR1S6C97PT0QY"
    # Poczekaj 30 sekund na ponowne poÅ‚Ä…czenie
    - delay:
        seconds: 30
    # SprawdÅº czy naprawione
    - if:
        - condition: not
          conditions:
            - condition: state
              entity_id: water_heater.bodynek_nb_tank
              state: "unavailable"
      then:
        - service: persistent_notification.create
          data:
            title: "âœ… Aquarea: PoÅ‚Ä…czenie przywrÃ³cone"
            message: |
              âœ… Integracja Aquarea dziaÅ‚a poprawnie po przeÅ‚adowaniu.

              Temp CWU: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
              Stan: {{ states('water_heater.bodynek_nb_tank') }}
            notification_id: aquarea_watchdog
      else:
        - service: persistent_notification.create
          data:
            title: "âŒ Aquarea: Problem nadal wystÄ™puje"
            message: |
              âŒ PrzeÅ‚adowanie nie pomogÅ‚o. MoÅ¼liwe przyczyny:
              - Problem z serwerami Panasonic Aquarea Cloud
              - Problem z adapterem WiFi pompy (CZ-TAW1)

              ğŸ’¡ SprÃ³buj: restart Home Assistant lub sprawdÅº aplikacjÄ™ Comfort Cloud
            notification_id: aquarea_watchdog
  mode: single

# ============================================
# CWU O 13:00 - NIEZALEÅ»NE OD CHMURY PANASONIC
# ============================================

- id: cwu_scheduled_1300
  alias: "[CWU] Harmonogram 13:00 - grzanie niezaleÅ¼ne od chmury"
  description: "O 13:00 wÅ‚Ä…cza wymuszenie CWU jeÅ›li temp < cel. Backup dla harmonogramu Aquarea Cloud."
  trigger:
    - platform: time
      at: "13:02:00"
  condition:
    # Wszystkie warunki muszÄ… byÄ‡ speÅ‚nione
    - condition: and
      conditions:
        # 1. Integracja dostÄ™pna
        - condition: not
          conditions:
            - condition: state
              entity_id: water_heater.bodynek_nb_tank
              state: "unavailable"
        # 2. CWU nie grzeje aktualnie
        - condition: not
          conditions:
            - condition: state
              entity_id: water_heater.bodynek_nb_tank
              state: "heating"
        # 3. Temperatura wody < cel, czyli potrzebuje grzania
        - condition: template
          value_template: >
            {% set current = state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) %}
            {% set target = state_attr('water_heater.bodynek_nb_tank', 'temperature') | float(55) %}
            {{ current < target }}
  action:
    # Powiadomienie o uruchomieniu
    - service: persistent_notification.create
      data:
        title: "ğŸŒ¡ï¸ CWU: Uruchamiam grzanie o 13:02"
        message: |
          ğŸ”„ WÅ‚Ä…czam wymuszenie CWU (backup harmonogramu chmury)

          Temp aktualna: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
          Temp docelowa: {{ state_attr('water_heater.bodynek_nb_tank', 'temperature') }}Â°C
        notification_id: cwu_scheduled_1300
    # WÅ‚Ä…cz wymuszenie CWU
    - service: switch.turn_on
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    # Czekaj aÅ¼ temperatura osiÄ…gnie cel (max 2h)
    - wait_template: >
        {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) >=
           state_attr('water_heater.bodynek_nb_tank', 'temperature') | float(55) }}
      timeout:
        hours: 2
      continue_on_timeout: true
    # WyÅ‚Ä…cz wymuszenie CWU
    - service: switch.turn_off
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    # Powiadomienie o zakoÅ„czeniu
    - service: persistent_notification.create
      data:
        title: "âœ… CWU: Grzanie zakoÅ„czone"
        message: |
          âœ… Temperatura osiÄ…gniÄ™ta!

          Temp koÅ„cowa: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
        notification_id: cwu_scheduled_1300
  mode: single

- id: cwu_scheduled_0432
  alias: "[CWU] Harmonogram 04:32 - grzanie niezaleÅ¼ne od chmury"
  description: "O 04:32 wÅ‚Ä…cza wymuszenie CWU jeÅ›li temp < cel. Backup dla harmonogramu Aquarea Cloud (rano)."
  trigger:
    - platform: time
      at: "04:32:00"
  condition:
    - condition: and
      conditions:
        # 1. Integracja dostÄ™pna
        - condition: not
          conditions:
            - condition: state
              entity_id: water_heater.bodynek_nb_tank
              state: "unavailable"
        # 2. CWU nie grzeje aktualnie
        - condition: not
          conditions:
            - condition: state
              entity_id: water_heater.bodynek_nb_tank
              state: "heating"
        # 3. Temperatura wody < cel
        - condition: template
          value_template: >
            {% set current = state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) %}
            {% set target = state_attr('water_heater.bodynek_nb_tank', 'temperature') | float(55) %}
            {{ current < target }}
  action:
    - service: persistent_notification.create
      data:
        title: "ğŸŒ¡ï¸ CWU: Uruchamiam grzanie o 04:32"
        message: |
          ğŸ”„ WÅ‚Ä…czam wymuszenie CWU (backup harmonogramu chmury - rano)

          Temp aktualna: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
          Temp docelowa: {{ state_attr('water_heater.bodynek_nb_tank', 'temperature') }}Â°C
        notification_id: cwu_scheduled_0432
    - service: switch.turn_on
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    - wait_template: >
        {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') | float(0) >=
           state_attr('water_heater.bodynek_nb_tank', 'temperature') | float(55) }}
      timeout:
        hours: 2
      continue_on_timeout: true
    - service: switch.turn_off
      target:
        entity_id: switch.bodynek_nb_wymus_c_w_u
    - service: persistent_notification.create
      data:
        title: "âœ… CWU: Grzanie zakoÅ„czone"
        message: |
          âœ… Temperatura osiÄ…gniÄ™ta!

          Temp koÅ„cowa: {{ state_attr('water_heater.bodynek_nb_tank', 'current_temperature') }}Â°C
        notification_id: cwu_scheduled_0432
  mode: single

# ============================================
# SEZONOWY TARGET SOC - AUTOMATYCZNA AKTUALIZACJA SUWAKA
# ============================================

- id: battery_seasonal_target_soc_startup
  alias: "[Bateria] Ustaw sezonowy Target SOC przy starcie HA"
  description: "Przy restarcie HA ustawia suwak Target SOC na sezonowe max (90% zima, 85% wiosna/jesieÅ„, 80% lato)"
  trigger:
    - platform: homeassistant
      event: start
  action:
    # DÅ‚uÅ¼szy delay Å¼eby sensor template byÅ‚ juÅ¼ dostÄ™pny
    - delay:
        seconds: 60
    - service: input_number.set_value
      target:
        entity_id: input_number.battery_target_soc
      data:
        value: "{{ state_attr('sensor.bateria_limity_soc', 'max_soc') | int(80) }}"
    - service: persistent_notification.create
      data:
        title: "ğŸ”‹ Target SOC ustawiony na sezonowy max"
        message: |
          âœ… Suwak Target SOC ustawiony na {{ state_attr('sensor.bateria_limity_soc', 'max_soc') }}%

          **Sezon:** {{ state_attr('sensor.bateria_limity_soc', 'season') }}
          **Limity:** {{ states('sensor.bateria_limity_soc') }}
        notification_id: battery_seasonal_target_soc
  mode: single

- id: battery_seasonal_target_soc_monthly
  alias: "[Bateria] Aktualizuj sezonowy Target SOC (1. dzieÅ„ miesiÄ…ca)"
  description: "Pierwszego dnia miesiÄ…ca o 00:05 aktualizuje suwak Target SOC na nowy sezonowy max"
  trigger:
    - platform: time
      at: "00:05:00"
  condition:
    # Tylko pierwszego dnia miesiÄ…ca
    - condition: template
      value_template: "{{ now().day == 1 }}"
  action:
    - service: input_number.set_value
      target:
        entity_id: input_number.battery_target_soc
      data:
        value: "{{ state_attr('sensor.bateria_limity_soc', 'max_soc') | int(80) }}"
    - service: persistent_notification.create
      data:
        title: "ğŸ”‹ Nowy sezon - Target SOC zaktualizowany"
        message: |
          âœ… Suwak Target SOC ustawiony na {{ state_attr('sensor.bateria_limity_soc', 'max_soc') }}%

          **Nowy sezon:** {{ state_attr('sensor.bateria_limity_soc', 'season') }}
          **Limity:** {{ states('sensor.bateria_limity_soc') }}
        notification_id: battery_seasonal_target_soc
  mode: single
